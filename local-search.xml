<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>oh my zsh打造好看好用的终端界面</title>
    <link href="/2026/01/14/zsh%E6%89%93%E9%80%A0%E5%A5%BD%E7%9C%8B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E7%95%8C%E9%9D%A2/"/>
    <url>/2026/01/14/zsh%E6%89%93%E9%80%A0%E5%A5%BD%E7%9C%8B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E7%95%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>使用zsh+oh my zsh可以打造如下图的美观好用的终端界面：<img src="/2026/01/14/zsh%E6%89%93%E9%80%A0%E5%A5%BD%E7%9C%8B%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E7%95%8C%E9%9D%A2/zsh%E9%A2%84%E8%A7%88.png" class="" title="zsh"></p><p>配置参考文档：<a href="https://blog.csdn.net/a143730/article/details/135573409">https://blog.csdn.net/a143730/article/details/135573409</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>zsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RxSwift入门</title>
    <link href="/2026/01/10/RxSwift%E5%85%A5%E9%97%A8/"/>
    <url>/2026/01/10/RxSwift%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="RxSwift简介"><a href="#RxSwift简介" class="headerlink" title="RxSwift简介"></a>RxSwift简介</h2><p>Rx是什么？<br></p><p><a href="http://reactivex.io/">ReactiveX</a>（简写: Rx） 是一个可以帮助我们简化 异步编程的框架。 <br></p><p><a href="https://github.com/ReactiveX/RxSwift">RxSwift</a> 是 <a href="https://github.com/Reactive-Extensions/Rx.NET">Rx</a> 的 <strong>Swift</strong> 版本。 <br></p><p>它尝试将原有的一些概念移植到 iOS&#x2F;macOS 平台。 <br></p><p>KVO，异步操作 和 流 全部被统一成抽象序列。这就是为什么 Rx 会如此简单，优雅和强大。 <br></p><h2 id="RxSwift-常用关键字与操作符速查手册"><a href="#RxSwift-常用关键字与操作符速查手册" class="headerlink" title="RxSwift 常用关键字与操作符速查手册"></a>RxSwift 常用关键字与操作符速查手册</h2><p>以下涵盖了 RxSwift 开发中最核心的概念、特征序列（Traits）、Subject 以及各类操作符。</p><h4 id="1-核心概念-Core-Concepts"><a href="#1-核心概念-Core-Concepts" class="headerlink" title="1. 核心概念 (Core Concepts)"></a>1. 核心概念 (Core Concepts)</h4><p>这是 RxSwift 的基石，理解它们是使用框架的前提。</p><table><thead><tr><th><strong>关键字</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>Observable</strong></td><td><strong>可观察序列</strong>。它是 Rx 的核心，代表一个随时间推移产生事件的流（Event Stream）。它可以发出 <code>Next</code> (新元素), <code>Error</code> (错误), <code>Completed</code> (完成) 三种事件。</td></tr><tr><td><strong>Observer</strong></td><td><strong>观察者</strong>。订阅 <code>Observable</code> 的对象，用来响应 Observable 发出的事件。</td></tr><tr><td><strong>DisposeBag</strong></td><td><strong>垃圾回收袋</strong>。用于管理订阅的生命周期。当 <code>DisposeBag</code> 被销毁时，放入其中的订阅会自动取消，防止内存泄漏。</td></tr><tr><td><strong>Subscription</strong></td><td><strong>订阅</strong>。连接 Observable 和 Observer 的桥梁。</td></tr><tr><td><strong>AnyObserver</strong></td><td>泛型观察者，用于将闭包或其他类型的观察者包装成统一的接口。</td></tr></tbody></table><h4 id="2-特征序列-Traits"><a href="#2-特征序列-Traits" class="headerlink" title="2. 特征序列 (Traits)"></a>2. 特征序列 (Traits)</h4><p>Traits 是对原始 Observable 的封装，专门用于特定的场景（如 UI 绑定或网络请求），能提高代码可读性和安全性。</p><ul><li><strong>UI 专用 (Cocoa)</strong><ul><li><strong>Driver</strong>: 专为 UI 设计。<strong>主要特点</strong>：1. 不会产生 Error（出错了会按指定策略处理）；2. 一定在主线程监听；3. 共享状态（Side Effects 只执行一次）。</li><li><strong>Signal</strong>: 与 Driver 类似，但它<strong>不重放</strong>最新的元素（类似于 PublishSubject），适用于点击事件等不需要回放状态的场景。</li></ul></li><li><strong>数据流&#x2F;网络专用</strong><ul><li><strong>Single</strong>: 只发出<strong>一个元素</strong>或<strong>一个错误</strong>。常用于 HTTP 请求（成功&#x2F;失败）。</li><li><strong>Completable</strong>: 不发出元素，只发出<strong>完成</strong>或<strong>错误</strong>。常用于关心“操作是否完成”的场景（如：写文件、更新缓存）。</li><li><strong>Maybe</strong>: 是 Single 和 Completable 的混合体。发出一个元素、完成、或者错误。</li></ul></li></ul><h4 id="3-Subject-主体"><a href="#3-Subject-主体" class="headerlink" title="3. Subject (主体)"></a>3. Subject (主体)</h4><p>Subject 既是 Observable 也是 Observer，它是连接非 Rx 代码和 Rx 代码的桥梁。</p><table><thead><tr><th><strong>类型</strong></th><th><strong>行为特征</strong></th></tr></thead><tbody><tr><td><strong>PublishSubject</strong></td><td><strong>只发送订阅之后产生的事件</strong>。订阅之前的事件会丢失。</td></tr><tr><td><strong>BehaviorSubject</strong></td><td><strong>发送订阅前的最后一个事件</strong>（如果有）以及订阅后的新事件。初始化时必须提供一个默认值。</td></tr><tr><td><strong>ReplaySubject</strong></td><td><strong>重放指定缓冲区大小的事件</strong>给新的订阅者，无论何时订阅。</td></tr><tr><td><strong>AsyncSubject</strong></td><td>只有当源 Observable <strong>完成 (Completed)</strong> 时，才发送最后一个元素给订阅者。</td></tr></tbody></table><h4 id="4-常用操作符-Operators"><a href="#4-常用操作符-Operators" class="headerlink" title="4. 常用操作符 (Operators)"></a>4. 常用操作符 (Operators)</h4><p>操作符用于创建、变换、过滤和组合 Observable。</p><p><strong>A. 创建操作符 (Creation)</strong></p><ul><li><code>just</code>: 创建只包含一个元素的序列。</li><li><code>of</code>: 创建包含固定数量元素的序列（如 <code>of(1, 2, 3)</code>）。</li><li><code>from</code>: 从数组、集合中创建序列。</li><li><code>create</code>: 自定义构建 Observable，手动控制 <code>onNext</code>, <code>onError</code>, <code>onCompleted</code>。</li><li><code>deferred</code>: 只有当有订阅者时才创建 Observable（懒加载）。</li></ul><p><strong>B. 变换操作符 (Transforming)</strong></p><ul><li><code>map</code>: 将序列中的元素进行转换（例如：Int 转 String）。</li><li><code>flatMap</code>: 将序列中的元素转换为新的 Observable，并将这些 Observables <strong>铺平</strong>成一个单一的序列。常用于<strong>链式网络请求</strong>。</li><li><code>flatMapLatest</code>: 与 <code>flatMap</code> 类似，但当新的事件到来时，会<strong>自动取消</strong>上一个未完成的任务。<strong>搜索框联想功能的必备神器</strong>。</li><li><code>scan</code>: 累加器。将前一次的结果和当前值结合，常用于计算总和或状态累积。</li></ul><p><strong>C. 过滤操作符 (Filtering)</strong></p><ul><li><code>filter</code>: 按照条件过滤元素，只允许符合条件的元素通过。</li><li><code>distinctUntilChanged</code>: 只有当新元素与上一个元素<strong>不相同</strong>时才发送。防止重复刷新。</li><li><code>take</code>: 只取前 N 个元素。</li><li><code>skip</code>: 跳过前 N 个元素。</li><li><code>debounce</code>: <strong>防抖</strong>。只有在指定时间内没有新元素产生时，才发送最后一个元素。常用于搜索框输入，减少服务器压力。</li><li><code>throttle</code>: <strong>节流</strong>。在指定时间间隔内，只发送第一个（或最后一个）元素。常用于防止按钮快速连击。</li></ul><p><strong>D. 组合操作符 (Combining)</strong></p><ul><li><code>merge</code>: 将多个 Observable 合并成一个，按照时间顺序发射数据。</li><li><code>zip</code>: <strong>配对</strong>。严格按照索引位置将多个 Observable 的元素打包成元组。必须所有源都产生第 N 个元素，才会发出第 N 个配对。</li><li><code>combineLatest</code>: 当任意一个源 Observable 发出新元素时，使用所有源的<strong>最新值</strong>进行组合。常用于表单验证（用户名+密码同时满足才亮起登录按钮）。</li><li><code>withLatestFrom</code>: 当第一个 Observable 发出元素时，携带第二个 Observable 的<strong>最新值</strong>。常用于点击按钮时获取当前的输入框内容。</li></ul><h4 id="5-线程调度-Schedulers"><a href="#5-线程调度-Schedulers" class="headerlink" title="5. 线程调度 (Schedulers)"></a>5. 线程调度 (Schedulers)</h4><ul><li><code>subscribeOn</code>: 决定<strong>序列构建和产生元素</strong>在哪个线程（通常用于将耗时操作切到后台）。</li><li><code>observeOn</code>: 决定<strong>在哪个线程监听和处理结果</strong>（通常用于切回主线程刷新 UI）。</li><li><code>MainScheduler.instance</code>: 主线程。</li><li><code>ConcurrentDispatchQueueScheduler</code>: 并发队列调度器（后台线程）。</li></ul><h4 id="6-内存管理与调试"><a href="#6-内存管理与调试" class="headerlink" title="6. 内存管理与调试"></a>6. 内存管理与调试</h4><ul><li><code>weak self</code>: 在闭包中务必使用 <code>[weak self]</code> 以避免循环引用。</li><li><code>share(replay:scope:)</code>: 共享订阅。避免一个 Observable 被多次订阅时重复执行副作用（如重复网络请求）。</li><li><code>debug()</code>: 打印调试信息，帮助查看事件流的生命周期。</li></ul><h2 id="PublishSubject和Obserable有什么区别"><a href="#PublishSubject和Obserable有什么区别" class="headerlink" title="PublishSubject&lt;String&gt;和Obserable&lt;String&gt;有什么区别"></a><code>PublishSubject&lt;String&gt;</code>和<code>Obserable&lt;String&gt;</code>有什么区别</h2><ul><li><strong><code>Observable&lt;String&gt;</code>（可观察序列）</strong><ul><li><strong>角色</strong>：它是<strong>只读</strong>的。</li><li><strong>行为</strong>：你只能“订阅”（Subscribe）它，等待它给你发数据。</li><li><strong>限制</strong>：你<strong>不能</strong>从外部手动往里面塞数据。你无法对它调用 <code>.onNext(&quot;abc&quot;)</code>。它的数据流向通常在创建时就已经定义好了（比如通过 <code>just</code>, <code>from</code>, <code>create</code> 等操作符）。</li><li><strong>比喻</strong>：就像<strong>看录播的电视节目</strong>。你只能看，不能冲进屏幕里改变剧情。</li></ul></li><li><strong><code>PublishSubject&lt;String&gt;</code>（发布主体）</strong><ul><li><strong>角色</strong>：它是<strong>读写</strong>的（既是 Observable，又是 Observer）。</li><li><strong>行为</strong>：<ol><li>你可以订阅它（把它当 Observable 用）。</li><li><strong>关键区别</strong>：你可以在任何时候、任何地方，手动调用 <code>.onNext(&quot;新数据&quot;)</code> 往里面塞数据，所有订阅了它的人都会立刻收到这个数据。</li></ol></li><li><strong>比喻</strong>：就像<strong>拿麦克风直播</strong>。下面的观众（订阅者）能听到声音，而你（开发者）可以随时拿起麦克风（Subject）说话（onNext），甚至把麦克风递给别人说话。</li></ul></li></ul><h2 id="什么是“界面事件”与“异步数据流”？"><a href="#什么是“界面事件”与“异步数据流”？" class="headerlink" title="什么是“界面事件”与“异步数据流”？"></a>什么是“界面事件”与“异步数据流”？</h2><ul><li><strong>界面事件（UI Events）</strong>：用户点击按钮、在输入框打字、滑动屏幕。<ul><li><em>传统处理</em>：用 <code>Target-Action</code>、<code>Delegate</code>（代理）、<code>KVO</code> 或 <code>NotificationCenter</code>。</li></ul></li><li><strong>异步数据流（Async Data Streams）</strong>：网络请求返回 JSON、定时器倒计时、读写数据库。<ul><li><em>传统处理</em>：用 <code>Closure</code>（闭包回调）、<code>Grand Central Dispatch (GCD)</code>、<code>OperationQueue</code>。</li></ul></li></ul><h2 id="RxSwift的传输链条"><a href="#RxSwift的传输链条" class="headerlink" title="RxSwift的传输链条"></a>RxSwift的传输链条</h2><p>1.创建监听序列：Observable</p><p>2.操作符变换：filter、map</p><p>3.订阅获取数据（数据从上到下传递）：subsuribe</p><p>4.最后取消订阅防止内存泄露：disposed</p><p><strong>在 RxSwift 的实际开发中，我们很少直接创建一个叫 <code>Observer</code> 的类。我们通常是把 “观察者的逻辑” 直接写在 <code>subscribe</code> 的参数里（说白了<code>Observer</code>就是<code>subscribe</code>后面的闭包）。</strong></p><p>参考文档：<a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/">https://beeth0ven.github.io/RxSwift-Chinese-Documentation/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>RxSwift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈：计算机网络知识汇总</title>
    <link href="/2026/01/04/%E6%9D%82%E8%B0%88%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2026/01/04/%E6%9D%82%E8%B0%88%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="TCP-的三次握⼿和四次挥⼿-："><a href="#TCP-的三次握⼿和四次挥⼿-：" class="headerlink" title="TCP 的三次握⼿和四次挥⼿ ："></a>TCP 的三次握⼿和四次挥⼿ ：</h3><ul><li><p>三次握⼿（建⽴连接）： Client 发送 SYN（我要连你）。 Server 回复 SYN + ACK（收到，我也要连你）。 Client 回复 ACK（收到，连接建⽴）。 </p></li><li><p>四次挥⼿（断开连接）： Client 发送 FIN（我发完了）。 Server 回复 ACK（知道了，但我可能还没发完）。 Server 发送 FIN（我也发完了）。 Client 回复 ACK（再⻅）。</p></li></ul><h3 id="为什么需要-TIME-WAIT-状态："><a href="#为什么需要-TIME-WAIT-状态：" class="headerlink" title="为什么需要 TIME_WAIT 状态："></a>为什么需要 TIME_WAIT 状态：</h3><ul><li>状态：主动关闭⽅在发送最后⼀个 ACK 后，进⼊ TIME_WAIT 状态，等待 2MSL（报⽂最⼤⽣存时间）。 </li><li>原因： 确保可靠关闭：如果最后⼀个 ACK 丢失，Server 会重传 FIN，Client 需要在 TIME_WAIT 状态下能收到并 再次发送 ACK。 防⽌旧报⽂⼲扰：确保本次连接中产⽣的所有⽹络包在⽹络中彻底消失，避免⼲扰下⼀次使⽤相同端⼝的 新连接。</li></ul><h3 id="为什么说-TCP-是可靠的，可靠性是怎么体现的"><a href="#为什么说-TCP-是可靠的，可靠性是怎么体现的" class="headerlink" title="为什么说 TCP 是可靠的，可靠性是怎么体现的"></a>为什么说 TCP 是可靠的，可靠性是怎么体现的</h3><ul><li>序列号与确认应答（ACK）：保证数据包按序到达，不丢包。 </li><li>超时重传：发送⽅发出数据后若未收到 ACK，会重新发送。 </li><li>流量控制：滑动窗⼝机制，防⽌发送⽅发太快接收⽅处理不过来。</li><li>拥塞控制：慢启动、拥塞避免等机制，防⽌⽹络拥堵。 </li><li>数据校验：校验和（Checksum）确保数据未损坏。</li></ul><h2 id="HTTP与HTTPS有什么区别"><a href="#HTTP与HTTPS有什么区别" class="headerlink" title="HTTP与HTTPS有什么区别"></a>HTTP与HTTPS有什么区别</h2><p>HTTP是明文传输，HTTPS是加密传输。</p><p>HTTPS在HTTP的基础上添加了SSL&#x2F;TLS协议，在传输数据前会加密。</p><p>HTTPS是需要申请SSL证书，从而建立加密通道和验证站点身份。</p><h2 id="GET与POST有什么区别"><a href="#GET与POST有什么区别" class="headerlink" title="GET与POST有什么区别"></a>GET与POST有什么区别</h2><p><strong>1. 语义与幂等性</strong></p><ul><li><strong>GET</strong> 用于<strong>获取</strong>资源，是<strong>幂等</strong>的（多次请求对服务器产生的影响是一样的，只会查数据）。</li><li><strong>POST</strong> 用于<strong>提交或修改</strong>数据，是<strong>非幂等</strong>的（每次请求都会创建新资源或修改状态）。</li></ul><p><strong>2. 参数位置与大小</strong></p><ul><li><strong>GET</strong> 参数拼接在 <strong>URL</strong> 后面，受浏览器或服务器对 URL 长度的限制（无法上传大文件）。</li><li><strong>POST</strong> 参数放在 <strong>Request Body</strong> 中，理论上没有大小限制。</li></ul><p><strong>3. 缓存与安全性</strong></p><ul><li><strong>GET</strong> 请求会被浏览器或 iOS 系统（URLCache）<strong>主动缓存</strong>，参数直接暴露在 URL 中，不适合传输密码等敏感信息。</li><li><strong>POST</strong> 请求默认<strong>不会被缓存</strong>，数据在 Body 中，相对隐蔽（但仍需 HTTPS 保证安全）。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈：项目常见基础知识汇总</title>
    <link href="/2026/01/01/%E6%9D%82%E8%B0%88%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2026/01/01/%E6%9D%82%E8%B0%88%EF%BC%9A%E9%A1%B9%E7%9B%AE%E5%B8%B8%E8%A7%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="MVC与MVVM设计模式的区别"><a href="#MVC与MVVM设计模式的区别" class="headerlink" title="MVC与MVVM设计模式的区别"></a>MVC与MVVM设计模式的区别</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>Model+View+Controller，控制模式为：</p><ul><li>View传指令到Controller</li><li>Controller完成业务逻辑后改变Model状态</li><li>Model将新的数据发送到View，用户得到反馈</li></ul><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>View+ViewModel+Model</p><p>View的变化会自动更新到ViewModel，ViewModel的变化也会自动同步到View上，通过数据来显示视图层</p><h3 id="优缺分析"><a href="#优缺分析" class="headerlink" title="优缺分析"></a>优缺分析</h3><p>MVVM模式的优点:</p><ul><li>低耦合:View可以独立于Model变化和修改,一个ViewModel可以绑定到不同的View上,当View变化的时候Model可以不变,当Model变化的时候View也可以不变。</li><li>可重用性: 可以把一些视图逻辑放在一个ViewModel里面,让很多View重用这段视图逻辑。</li><li>独立开发: 开发人员可以专注于业务逻辑和数据的开发,设计人员可以专注于页面的设计。</li></ul><p>MVVM和MVC的区别:</p><ul><li>MVC中Controller演变成MVVM中的ViewModel</li><li>MVVM通过数据来显示视图层而不是节点操作</li><li>MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验</li></ul><h2 id="MVVM是如何解耦的"><a href="#MVVM是如何解耦的" class="headerlink" title="MVVM是如何解耦的"></a>MVVM是如何解耦的</h2><p>数据绑定：MVVM 的核心是双向绑定或响应式绑定。<br>View 持有 ViewModel，但 ViewModel 不持有 View。<br>以RxSwift举例，是通过Observable监听然后互相传输数据，当 ViewModel 中的数据变化时，自动通知 View 更新，从而实现逻辑与 UI 的解耦。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式："><a href="#单例模式：" class="headerlink" title="单例模式："></a>单例模式：</h3><p>UIApplication.shard：每个应用程序都有且只有一个UI应用程序实例，由UIApplicationMain函数在应用程序启动时创建为单例对象。<br>URLSession.shared：管理网络连接。<br>NotificationCenter.defualt：管理iOS中的通知。<br>UserDefaults.standard：存储轻量级的本地。</p><p><strong>优点</strong>：<br>提供对唯一实例的受控访问：防止其他对象对自己实例化，确保所有对象都访问同一个实例。<br>节省系统资源：由于只存在一个对象，因此可以节省系统资源。<br>伸缩性：自己控制实例化的进程，因此易于修改</p><p><strong>缺点</strong>：<br>由于单例是全局共享的，很难保证其数据的安全性以及无法确定单例的当前状态<br>主要是由于单例状态的混乱所造成的。因为单例状态可以被其他人所修改，所以进行测试时，很难从一个干净的状态开始。</p>]]></content>
    
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈：Swift基础知识汇总</title>
    <link href="/2025/12/28/%E6%9D%82%E8%B0%88%EF%BC%9ASwift%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/"/>
    <url>/2025/12/28/%E6%9D%82%E8%B0%88%EF%BC%9ASwift%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="let和var的区别"><a href="#let和var的区别" class="headerlink" title="let和var的区别"></a>let和var的区别</h2><p><code>let</code>修饰不可变量</p><p><code>var</code>修饰可变量</p><h2 id="Swift访问控制"><a href="#Swift访问控制" class="headerlink" title="Swift访问控制"></a>Swift访问控制</h2><ul><li><code>open</code> 和 <code>public</code>可以访问当前定义模块任意源文件，也可访问通过<code>import</code>导入后的文件，不同的是<code>open</code>仅适用于类和类的成员，与public的区别在于可以被外面的模块继承</li><li><code>internal</code> 可以访问当前定义模块内的任意源文件</li><li><code>fileprivate</code> 严格限制访问当前文件</li><li><code>private</code> 限制在一个封闭的声明中使用以及在同一个文件的扩展中使用</li><li>访问级别设计指导原则：大的原则是权限大的不能定义在权限小中定义，如一个公共变量内部不使用权限小的类型，或一个函数比其参数或返回值拥有更高的访问级别</li><li>默认访问级别：<code>internal</code>（除了下面提到的几种特定的情况），多数情况下在代码中不用显示指定访问级别</li><li>作为独立目标应用程序的访问权限 <code>internal</code>权限在模块内部已足够使用，作为Framework的访问级别一般提供给外界使用，一般是 <code>open</code> <code>public</code>， 单元测试模块默认是当前模块可以任意访问，只有标有<code>open</code> <code>public</code>才能被其它模块使用</li></ul><h2 id="Swift的值类型与引用类型"><a href="#Swift的值类型与引用类型" class="headerlink" title="Swift的值类型与引用类型"></a>Swift的值类型与引用类型</h2><h4 id="值类型-Value-Types"><a href="#值类型-Value-Types" class="headerlink" title="值类型 (Value Types)"></a>值类型 (Value Types)</h4><ul><li><strong>代表:</strong> <code>struct</code>, <code>enum</code>, <code>tuple</code> 以及 Swift 的基础类型 (<code>Int</code>, <code>String</code>, <code>Array</code>, <code>Dictionary</code>, <code>Set</code>)。</li><li><strong>行为:</strong> 当你把它赋值给一个新变量，或者传参给函数时，系统会<strong>拷贝</strong>一份全新的数据。</li></ul><h4 id="引用类型-Reference-Types"><a href="#引用类型-Reference-Types" class="headerlink" title="引用类型 (Reference Types)"></a>引用类型 (Reference Types)</h4><ul><li><strong>代表:</strong> <code>class</code>, <code>actor</code>, <code>closure</code> (闭包)。</li><li><strong>行为:</strong> 当你把它赋值给一个新变量时，系统只拷贝了<strong>内存地址（指针）</strong>，它们指向堆内存中的同一个实例。</li></ul><h3 id="值类型与引用类型的内存位置与管理"><a href="#值类型与引用类型的内存位置与管理" class="headerlink" title="值类型与引用类型的内存位置与管理"></a>值类型与引用类型的内存位置与管理</h3><table><thead><tr><th align="left">特性</th><th align="left">值类型 (Value Type)</th><th align="left">引用类型 (Reference Type)</th></tr></thead><tbody><tr><td align="left"><strong>内存区域</strong></td><td align="left">通常在 <strong>栈 (Stack)</strong> 上（快）</td><td align="left">都在 <strong>堆 (Heap)</strong> 上 (较慢)</td></tr><tr><td align="left"><strong>内存管理</strong></td><td align="left">作用域结束自动释放</td><td align="left">通过 <strong>ARC</strong> (引用计数) 管理</td></tr><tr><td align="left"><strong>安全性</strong></td><td align="left">线程安全 (因为数据是独立的)</td><td align="left">线程不安全 (多线程同时改同一个实例需加锁)</td></tr></tbody></table><blockquote><p><strong>注意：</strong> 如果 Struct 里包含 Class 属性，或者数据量很大，Struct 的数据也可能存储在堆上，但逻辑行为依然是值类型。</p></blockquote><hr><h3 id="可变性的区别"><a href="#可变性的区别" class="headerlink" title="可变性的区别"></a>可变性的区别</h3><p><strong>值类型 (Struct):</strong><br>如果你用 <code>let</code> 声明一个 Struct 实例，那么<strong>它整体都被锁死了</strong>，连里面的属性都不能改（即使属性本身是 <code>var</code>）。</p><p><strong>引用类型 (Class):</strong><br>如果你用 <code>let</code> 声明一个 Class 实例，只是意味着<strong>这个变量不能指向别的对象</strong>，但<strong>对象内部的属性是可以修改的</strong>。</p><h3 id="什么时候用哪个？"><a href="#什么时候用哪个？" class="headerlink" title="什么时候用哪个？"></a>什么时候用哪个？</h3><p>Swift 官方极其推崇 <strong>优先使用 Struct (值类型)</strong>。</p><ul><li><strong>使用 Struct (值类型) 的情况 (90%):</strong><ul><li>用来表示数据模型 (Model)，如 <code>User</code>, <code>Product</code>, <code>Coordinate</code>。</li><li>你需要独立性，不希望被意外修改。</li><li>**Swift 的 <code>Array</code> 和 <code>String</code> 都是 Struct！。</li></ul></li><li><strong>使用 Class (引用类型) 的情况 (10%):</strong><ul><li>你需要<strong>共享状态</strong> (Shared Mutable State)。例如 <code>ViewModel</code> (因为页面都要监听同一个 ViewModel 的变化)。</li><li>你需要<strong>继承</strong> (Struct 不支持继承，Class 支持)。</li><li>你需要控制对象的生命周期 (<code>deinit</code>)。</li></ul></li></ul><h3 id="写时复制-Copy-on-Write-COW"><a href="#写时复制-Copy-on-Write-COW" class="headerlink" title="写时复制 (Copy-on-Write, COW)"></a>写时复制 (Copy-on-Write, COW)</h3><p>当定义的值类型出现非常大的数据量时，如值类型定义的array，当把 <code>array1</code> 赋值给 <code>array2</code> 时，它们在底层<strong>暂时共享</strong>同一块内存。只有当你<strong>真的去修改</strong> <code>array2</code> 的内容时，系统才会真正执行拷贝操作。如果只是读取，就不会拷贝。这保证了值类型的高效性。</p><h2 id="Swift中的inout"><a href="#Swift中的inout" class="headerlink" title="Swift中的inout"></a>Swift中的<code>inout</code></h2><p>在 Swift 中，函数的参数默认是 <strong>值传递</strong>。</p><p>而 <strong><code>inout</code></strong> 关键字可以让参数变成 <strong>引用传递</strong>（更准确地说是：复制进去 → 修改 → 再复制出来），这样在函数里修改参数值，会直接影响外部变量。</p><p>然后swift中默认是不能修改传入的参数的，如果修改了会直接报错。</p><p><code>inout</code> 的底层原理</p><p>Swift 的 <code>inout</code> 并不等于 C++ 那种裸引用，它是 <strong>“复制入 - 修改 - 复制出”</strong> 的机制：</p><ol><li>调用时，把外部变量的值 <strong>复制到形参</strong>。</li><li>函数内部对形参的修改，都会作用在这个临时拷贝上。</li><li>函数返回前，把修改后的值 <strong>再写回到外部变量</strong>。</li></ol><p>这样做的好处：</p><ul><li>避免直接暴露内存引用，保证了安全性。</li><li>但在编译器优化下，简单类型（如 Int、Struct）可能会直接就地修改，避免性能损失。</li></ul><h2 id="什么是逃逸闭包，逃逸闭包和普通闭包的区别"><a href="#什么是逃逸闭包，逃逸闭包和普通闭包的区别" class="headerlink" title="什么是逃逸闭包，逃逸闭包和普通闭包的区别"></a>什么是逃逸闭包，逃逸闭包和普通闭包的区别</h2><p>一般来说，闭包参数在函数调用的过程中会被执行完，也就是说它的生命周期和函数一样，函数一返回，闭包就结束了。</p><p>但如果函数<strong>把闭包保存起来，留到函数返回之后才执行</strong>，这种闭包就叫 <strong>逃逸闭包</strong>。</p><p>无论是什么闭包，都是值类型，但是对于普通闭包而言，swift会对其进行编译优化，因为他的生命周期和函数是相一致的，所以可以直接分配到栈上，但是对于逃逸闭包而言，闭包可能在函数返回后执行，不能放在栈上（函数栈帧销毁会导致悬空指针）。编译器会把闭包分配到 <strong>堆上</strong>。传入时需要 <strong>copy</strong> 操作，从栈复制到堆，因为存活时间不确定，必须通过 <strong>ARC（引用计数）</strong> 管理生命周期。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Swift</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一图知常用iOS数据持久化工具</title>
    <link href="/2025/12/25/%E4%B8%80%E5%9B%BE%E7%9F%A5%E5%B8%B8%E7%94%A8iOS%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    <url>/2025/12/25/%E4%B8%80%E5%9B%BE%E7%9F%A5%E5%B8%B8%E7%94%A8iOS%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>话不多说直接上图，下图可以很清晰的展示常用数据持久化工具以及应用场景：</p><img src="/2025/12/25/%E4%B8%80%E5%9B%BE%E7%9F%A5%E5%B8%B8%E7%94%A8iOS%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E5%B7%A5%E5%85%B7/iOS%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96.png" class=""><p>参考文档：<a href="https://www.jianshu.com/p/39ba5db32bb5">https://www.jianshu.com/p/39ba5db32bb5</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈：iOS的内存管理</title>
    <link href="/2025/12/20/%E6%B5%85%E8%B0%88%EF%BC%9AiOS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2025/12/20/%E6%B5%85%E8%B0%88%EF%BC%9AiOS%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="iOS的内存管理机制（ARC）"><a href="#iOS的内存管理机制（ARC）" class="headerlink" title="iOS的内存管理机制（ARC）"></a>iOS的内存管理机制（ARC）</h2><p> Swift 使用 ARC 来跟踪和管理应用程序的内存，其主要是由Objective-C语言提供的。ARC是一种自动化的内存管理机制，它通过在编译时插入内存管理代码来自动管理对象的引用计数。ARC机制可以让开发者不用手动管理对象的引用计数，从而减少了内存泄漏和野指针等问题的发生。<br></p><h3 id="总的来说："><a href="#总的来说：" class="headerlink" title="总的来说："></a>总的来说：</h3><p>Swift中每个对象都有一个**【被引用计数】**；<br>当对象A被引用时（实例），对象A的被引用计数会 + 1；<br>当对象A被放弃引用时，对象A的被引用计数会 - 1；<br>只有当对象A的被引用计数为 0 的时候，ARC才会释放对象A的内存。</p><p><strong>ARC的好处（与MRC的区别）</strong>：使用ARC，<strong>开发者不再需要手动的<code>retain/release/autorelease</code></strong>。编译器会自动插入对应的代码，再结合Objective C的runtime，实现自动引用计数。</p><h2 id="循环引用的产生以及如何解决"><a href="#循环引用的产生以及如何解决" class="headerlink" title="循环引用的产生以及如何解决"></a>循环引用的产生以及如何解决</h2><h3 id="产生：强引用未及时释放导致双方都持有对方的强引用"><a href="#产生：强引用未及时释放导致双方都持有对方的强引用" class="headerlink" title="产生：强引用未及时释放导致双方都持有对方的强引用"></a>产生：强引用未及时释放导致双方都持有对方的强引用</h3><p>为了防止实例在仍然需要时被释放，属性、常量或变量在分配实例时会建立对实例的**强引用。**而当两个实例对应的变量设置为nil时，变量与实例强引用小时，但实例之间的强引用还存在，就会导致ARC无法释放内存</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><ul><li><p><strong>弱引用weak</strong></p></li><li><p><strong>无主引用Unowned</strong>：与weak的区别在于weak是可选类型，可以设置为nil，而Unowned是值类型，其必须持有具体的值。</p></li><li><p><strong>Autoreleasepool 自动释放池</strong></p><p>在Swift中，自动释放池（Autorelease Pool）是一种用于管理内存释放的机制，它可以减少内存峰值并提高内存使用效率。自动释放池允许您暂时保留对象，直到您离开当前代码块，然后自动释放它们。</p><p>在Swift中，您可以使用 autoreleasepool 块来创建自动释放池。在 autoreleasepool 块中创建的对象都会被加入到自动释放池中。当程序离开该块时，自动释放池将被清空，并释放其中的所有对象。</p><p>自动释放池以栈的形式实现：当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中，当自动释放池被回收时，它们从栈中被删除，并且会给池子里面所有的对象都会做一次release操作。<br>在iOS程序运行过程中，会创建无数个池子。这些池子都是以栈结构存在（先进后出）</p></li></ul><p>参考文档：<a href="https://blog.csdn.net/ScheenDuan/article/details/137113726?spm=1001.2014.3001.5502">https://blog.csdn.net/ScheenDuan/article/details/137113726?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈：RunLoop</title>
    <link href="/2025/12/18/%E6%B5%85%E8%B0%88%EF%BC%9ARunLoop/"/>
    <url>/2025/12/18/%E6%B5%85%E8%B0%88%EF%BC%9ARunLoop/</url>
    
    <content type="html"><![CDATA[<h2 id="iOS-中的-Runloop"><a href="#iOS-中的-Runloop" class="headerlink" title="iOS 中的 Runloop"></a>iOS 中的 Runloop</h2><p>本质：RunLoop是一个**事件循环机制，用于管理线程中的事件和消息。**它允许线程在没有任务的情况下休眠，并在有任务需要处理时唤醒线程。<br>作用：</p><ul><li><strong>处理输入源</strong>：RunLoop负责处理输入源，包括用户界面事件、触摸事件、定时器事件、网络事件等，通过RunLoop能够有效地处理这些事件，让应用程序的响应更加及时。</li><li><strong>保持线程活动</strong>（线程保活）：RunLoop能够保持线程活动，即使在没有任务时，RunLoop也会让线程休眠而不会退出，以便随时处理来自输入源的事件。</li><li><strong>定时器功能</strong>：RunLoop提供了一些定时器功能，例如延迟执行和重复执行某个任务。通过定时器功能，可以很方便地在指定时间执行任务。</li><li><strong>优化性能</strong>：RunLoop能够优化应用程序的性能，通过RunLoop能够让应用程序在有任务需要处理时及时唤醒线程，而在没有任务时让线程休眠，从而避免了线程的空转，减少了CPU的占用，提高了应用程序的性能。</li></ul><p>参考文档：<a href="https://blog.csdn.net/ScheenDuan/article/details/142579145?spm=1001.2014.3001.5502">https://blog.csdn.net/ScheenDuan/article/details/142579145?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>统一颜色管理与黑夜模式适配</title>
    <link href="/2025/12/14/%E7%BB%9F%E4%B8%80%E9%A2%9C%E8%89%B2%E7%AE%A1%E7%90%86%E4%B8%8E%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F%E9%80%82%E9%85%8D/"/>
    <url>/2025/12/14/%E7%BB%9F%E4%B8%80%E9%A2%9C%E8%89%B2%E7%AE%A1%E7%90%86%E4%B8%8E%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F%E9%80%82%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="正文在此"><a href="#正文在此" class="headerlink" title="正文在此"></a>正文在此</h1><h2 id="统一项目中的所有颜色"><a href="#统一项目中的所有颜色" class="headerlink" title="统一项目中的所有颜色"></a>统一项目中的所有颜色</h2><p>项目中可能会用到相当多的颜色设置，因此可以创建一个Config文件夹专门用于存放全局变量，方便日后的修改。而对于颜色的定义，则可以用<strong>DynamicColor</strong>库进行管理，可以使用十六进制数进行定义，免于传统RGB的定义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># https://github.com/yannickl/DynamicColor</span><br>pod <span class="hljs-string">&quot;DynamicColor&quot;</span><br></code></pre></td></tr></table></figure><p>统一颜色模板：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/// 主色调</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> primaryColor: <span class="hljs-type">UIColor</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">DynamicColor</span>(hex: <span class="hljs-number">0xd6271c</span>)&#125;<br><br><span class="hljs-comment">/// 暗一点 主色调</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> primary30 : <span class="hljs-type">UIColor</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-type">DynamicColor</span>(hex: <span class="hljs-number">0xa92e29</span>)&#125;<br><br><span class="hljs-comment">/// 链接颜色</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> link : <span class="hljs-type">UIColor</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-type">DynamicColor</span>(hex: <span class="hljs-number">0x2440b3</span>)&#125;<br><br><span class="hljs-comment">/// 主色调，暗一点按钮颜色</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> primaryButton : <span class="hljs-type">UIColor</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-type">DynamicColor</span>(hex: <span class="hljs-number">0x596c94</span>)&#125;<br><br><span class="hljs-comment">/// vip金色</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> vipBorder : <span class="hljs-type">UIColor</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-type">DynamicColor</span>(hex: <span class="hljs-number">0xc4b2ad</span>)&#125;<br><br></code></pre></td></tr></table></figure><h2 id="黑夜模式适配"><a href="#黑夜模式适配" class="headerlink" title="黑夜模式适配"></a>黑夜模式适配</h2><p>在IOS13以后，iPhone支持了黑夜模式。但是在黑夜模式下字体的颜色需要重新适配，这时候我们可以通过提前定义好黑夜模式下的字体颜色，并通过以下函数，便可以自动进行切换。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">initColor</span>(<span class="hljs-params">normal</span>:<span class="hljs-type">UIColor</span>,<span class="hljs-params">dark</span>:<span class="hljs-type">UIColor</span>) -&gt; <span class="hljs-type">UIColor</span> &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">#available</span>(<span class="hljs-keyword">iOS</span> <span class="hljs-number">13.0</span>, <span class="hljs-operator">*</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">UIColor</span> &#123; (traitCollection) -&gt; <span class="hljs-type">UIColor</span> <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">return</span> traitCollection.userInterfaceStyle <span class="hljs-operator">==</span> .dark <span class="hljs-operator">?</span> dark : normal<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//用浅色</span><br>        <span class="hljs-keyword">return</span> normal<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串国际化与R.swift框架</title>
    <link href="/2025/12/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%BD%E9%99%85%E5%8C%96%E4%B8%8ER-swift%E6%A1%86%E6%9E%B6/"/>
    <url>/2025/12/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9B%BD%E9%99%85%E5%8C%96%E4%B8%8ER-swift%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="正文在此"><a href="#正文在此" class="headerlink" title="正文在此"></a>正文在此</h1><h2 id="字符串国际化"><a href="#字符串国际化" class="headerlink" title="字符串国际化"></a>字符串国际化</h2><p>为了给不同地区的用户做适配，通常项目中需要包含多种语言包，用于显示应用层面的部分提示。至于应用获取到的内容的语言则由后端服务器决定，因此我们只需要对应用可能出现的提示词做国际化即可。<br></p><p>具体步骤如下：</p><h3 id="向项目中添加需要支持的语言"><a href="#向项目中添加需要支持的语言" class="headerlink" title="向项目中添加需要支持的语言"></a>向项目中添加需要支持的语言</h3><ol><li>在左侧导航栏点击<strong>项目根目录</strong>。</li><li>在右侧主界面选择 <strong>PROJECT</strong>。</li><li>点击上面的 <strong>Info</strong> 标签页。</li><li>找到 <strong>Localizations</strong> 区域。</li><li>点击 <strong>+</strong> 号，选择想要支持的语言（例如：<code>Chinese, Simplified</code> 简体中文）。</li></ol><h3 id="创建Localizable-strings文件"><a href="#创建Localizable-strings文件" class="headerlink" title="创建Localizable.strings文件"></a>创建<code>Localizable.strings</code>文件</h3><ol><li>在左侧文件导航栏，右键点击根目录 -&gt; <strong>New File…</strong></li><li>在搜索框输入 “strings”，选择 <strong>Strings File</strong>，创建即可。</li><li>注意要将文件命名为 <strong><code>Localizable.strings</code></strong>（非必要不要变化文件名）。</li></ol><p>注意，创建文件后要在右侧<strong>File Inspector</strong>处勾选需要的文件，此时导航栏中将出现若干个子文件，对应的是不同语言的字符串。</p><h3 id="填写翻译内容"><a href="#填写翻译内容" class="headerlink" title="填写翻译内容"></a>填写翻译内容</h3><p>例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//网络相关_en</span><br><span class="hljs-type">ErrorNetworkUnknownHost</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Server not found&quot;</span>;<br><span class="hljs-type">ErrorNetworkConnect</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Failed to connect to the server&quot;</span>;<br><span class="hljs-type">ErrorNetworkTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Connection server timeout&quot;</span>;<br><span class="hljs-type">ErrorNetworkNotAuth</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Login information expired&quot;</span>;<br><span class="hljs-type">ErrorNetworkNotPermission</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;You do not have permission to access&quot;</span>;<br><span class="hljs-type">ErrorNetworkNotFound</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;The content you accessed does not exist&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//网络相关_zh</span><br><span class="hljs-type">ErrorNetworkUnknownHost</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;找不到服务器&quot;</span>;<br><span class="hljs-type">ErrorNetworkConnect</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;连接服务器失败&quot;</span>;<br><span class="hljs-type">ErrorNetworkTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;连接服务器超时&quot;</span>;<br><span class="hljs-type">ErrorNetworkNotAuth</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;登录信息过期&quot;</span>;<br><span class="hljs-type">ErrorNetworkNotPermission</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你没有权限访问&quot;</span>;<br><span class="hljs-type">ErrorNetworkNotFound</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你访问的内容不存在&quot;</span>;<br></code></pre></td></tr></table></figure><h3 id="对应用名称国际化"><a href="#对应用名称国际化" class="headerlink" title="对应用名称国际化"></a>对应用名称国际化</h3><p>创建<code>InfoPlist.strings</code>文件，内容为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// zh</span><br><span class="hljs-type">CFBundleName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Taopi云音乐&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// en</span><br><span class="hljs-type">CFBundleName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CloudMusic&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="R-swift的使用"><a href="#R-swift的使用" class="headerlink" title="R.swift的使用"></a>R.swift的使用</h2><h3 id="能干啥"><a href="#能干啥" class="headerlink" title="能干啥"></a>能干啥</h3><p> 能将资源（图片，文件等）生成类，更方便书写代码，例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> icon <span class="hljs-operator">=</span> <span class="hljs-type">R</span>.image.settingsIcon()<br><span class="hljs-keyword">let</span> font <span class="hljs-operator">=</span> <span class="hljs-type">R</span>.font.sanFrancisco(size: <span class="hljs-number">42</span>)<br><span class="hljs-keyword">let</span> color <span class="hljs-operator">=</span> <span class="hljs-type">R</span>.color.indicatorHighlight()<br><span class="hljs-keyword">let</span> viewController <span class="hljs-operator">=</span> <span class="hljs-type">CustomViewController</span>(nib: <span class="hljs-type">R</span>.nib.customView)<br><span class="hljs-keyword">let</span> string <span class="hljs-operator">=</span> <span class="hljs-type">R</span>.string.localizable.welcomeWithName(<span class="hljs-string">&quot;Arthur Dent&quot;</span>)<br></code></pre></td></tr></table></figure><p>方便访问如上面提到的应用内通知、应用图片资源或是自定义的颜色信息。</p><h3 id="怎么开始"><a href="#怎么开始" class="headerlink" title="怎么开始"></a>怎么开始</h3><p>依然是pod安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pod <span class="hljs-string">&#x27;R.swift&#x27;</span><br></code></pre></td></tr></table></figure><p>安装后需要进行一定配置，请根据官方文档进行，原仓库地址为<a href="https://github.com/mac-cain13/R.swift">https://github.com/mac-cain13/R.swift</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TangramKit的使用</title>
    <link href="/2025/12/12/TangramKit%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/12/12/TangramKit%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h1><p>接下来的一些博客我都将介绍一些在一个企业级项目中学到的东西，开始之前先介绍一下整个项目的规划。我的项目初衷是基于市面上主流的音乐软件而仿造的在线音乐播放器。能支持线上播放、下载音乐，创建歌单，发布与回复评论，同时还集成了应用内聊天功能。</p><h1 id="项目仓库"><a href="#项目仓库" class="headerlink" title="项目仓库"></a>项目仓库</h1><p>项目进度已公开在Github上，地址 <a href="https://github.com/TaopiTTT/MyCloudMusic">https://github.com/TaopiTTT/MyCloudMusic</a> ，觉得不错的可以给个Star～</p><h1 id="正片在此"><a href="#正片在此" class="headerlink" title="正片在此"></a>正片在此</h1><h2 id="为什么选用TangramKit"><a href="#为什么选用TangramKit" class="headerlink" title="为什么选用TangramKit"></a>为什么选用TangramKit</h2><p>众所周知，IOS开发中最为广泛使用的布局库莫过于<strong>SnapKit</strong>，是基于Auto Layuot的语法糖，旨在让布局写起来更加简单。但由于是对原生Auto Layout的封装，因此在面对大规模布局同时采用纯代码构建时会显得代码非常冗长并且不好修改。<br></p><p>因而为了简化布局的繁琐步骤，本次项目将采用TangramKit，核心优势就是采用<strong>布局容器</strong>，即自定义一个container，并将所有子视图放入容器中。届时，容器将会自动计算Frame并采用自动布局，减少我们的代码量。</p><h2 id="TangramKit快速上手"><a href="#TangramKit快速上手" class="headerlink" title="TangramKit快速上手"></a>TangramKit快速上手</h2><p>首先需要安装TangramKit，直接采用Cocoapod包管理器即可，在podfile中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pod <span class="hljs-string">&#x27;TangramKit&#x27;</span><br></code></pre></td></tr></table></figure><p>TangramKit原仓库地址为：<a href="https://github.com/youngsoft/TangramKit">https://github.com/youngsoft/TangramKit</a> <br></p><p>这里给出一个示例，来体验容器的自动布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">viewDidLoad</span>() &#123;<br>    <span class="hljs-keyword">super</span>.viewDidLoad()<br>    view.backgroundColor <span class="hljs-operator">=</span> .colorBackground<br><br>    <span class="hljs-comment">// 创建一个相对容器</span><br>    <span class="hljs-keyword">let</span> container <span class="hljs-operator">=</span> <span class="hljs-type">TGRelativeLayout</span>()<br><br>    <span class="hljs-comment">//从安全区开始</span><br>    container.tg_top.equal(<span class="hljs-type">TGLayoutPos</span>.tg_safeAreaMargin)<br>    container.tg_leading.equal(<span class="hljs-type">TGLayoutPos</span>.tg_safeAreaMargin)<br>    container.tg_trailing.equal(<span class="hljs-type">TGLayoutPos</span>.tg_safeAreaMargin)<br>    container.tg_bottom.equal(<span class="hljs-type">TGLayoutPos</span>.tg_safeAreaMargin)<br>    view.addSubview(container)<br><br>    <span class="hljs-comment">// LOGO</span><br>    <span class="hljs-keyword">let</span> logoView <span class="hljs-operator">=</span> <span class="hljs-type">UIImageView</span>(image: <span class="hljs-type">R</span>.image.splashLogo())<br>    logoView.tg_width.equal(<span class="hljs-number">188</span>)<br>    logoView.tg_height.equal(<span class="hljs-number">31</span>)<br>    logoView.tg_bottom.equal(copyrightView.tg_top).offset(<span class="hljs-number">16</span>)<br>    logoView.tg_centerX.equal(<span class="hljs-number">0</span>)<br>    logoView.contentMode <span class="hljs-operator">=</span> .scaleAspectFill<br>    container.addSubview(logoView)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的代码，可以轻松实现安全区的布局(下图中采用灰色进行范围展示)，并且可以方便地基于安全区展示子视图。</p><img src="/2025/12/12/TangramKit的使用/Pro01_1.png"  alt="布局样例" style="zoom:30%;"/>]]></content>
    
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从一堆Demo中学到的IOS开发知识</title>
    <link href="/2025/11/21/%E4%BB%8E%E4%B8%80%E5%A0%86Demo%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84IOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    <url>/2025/11/21/%E4%BB%8E%E4%B8%80%E5%A0%86Demo%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84IOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>感谢忧寒学长给我分享的一些Demo作为我IOS应用开发的入门练习，我从18个Demo中学到了很多有意思的效果，也让我快速上手了IOS应用的开发流程。现在马上要进入项目练习了，于是写个博客记录一下这些学习经验。</p><h1 id="个人仓库"><a href="#个人仓库" class="headerlink" title="个人仓库"></a>个人仓库</h1><p>所有源码已上传<strong>github</strong><a href="https://github.com/TaopiTTT/IOSDemos">https://github.com/TaopiTTT/IOSDemos</a>，觉得有帮助的请给个star～</p><h1 id="正片在此"><a href="#正片在此" class="headerlink" title="正片在此"></a>正片在此</h1><h2 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h2><p>Demo1的效果是点击按钮实现字体切换，具体实现上使用了TableView的形式，对于初学者往往要掌握以下几点：<br></p><img src="/2025/11/21/%E4%BB%8E%E4%B8%80%E5%A0%86Demo%E4%B8%AD%E5%AD%A6%E5%88%B0%E7%9A%84IOS%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/Demo1.jpg" class="" title="Demo1"><h3 id="1-懒加载"><a href="#1-懒加载" class="headerlink" title="1.懒加载"></a>1.懒加载</h3><p>懒加载主要作用是延迟初始化，通俗点来讲就是在需要使用的时候才进行初始化，在实际项目可以起到节约性能开销的作用，从而加载速度更快</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> tableView: <span class="hljs-type">UITableView</span> <span class="hljs-operator">=</span> &#123;<br>    <span class="hljs-keyword">let</span> tableView <span class="hljs-operator">=</span> <span class="hljs-type">UITableView</span>(frame: <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-type">ScreenWidth</span>, height: <span class="hljs-number">500</span>))<br><br>    tableView.dataSource <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br>    tableView.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br>    tableView.register(<span class="hljs-type">UITableViewCell</span>.<span class="hljs-keyword">self</span>, forCellReuseIdentifier: <span class="hljs-type">ViewController</span>.<span class="hljs-keyword">self</span>.reuseIdentify)<br>    <span class="hljs-keyword">return</span> tableView<br>&#125;()<br></code></pre></td></tr></table></figure><h3 id="2-设置数据源方法与重用"><a href="#2-设置数据源方法与重用" class="headerlink" title="2.设置数据源方法与重用"></a>2.设置数据源方法与重用</h3><p>在创建UITableView类时，通常需要指定数据源方法，其中包括两个重要方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">tableView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">tableView</span>: <span class="hljs-type">UITableView</span>, <span class="hljs-params">numberOfRowsInSection</span> <span class="hljs-params">section</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;&#125;<br>    <br><span class="hljs-keyword">func</span> <span class="hljs-title function_">tableView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">tableView</span>: <span class="hljs-type">UITableView</span>, <span class="hljs-params">cellForRowAt</span> <span class="hljs-params">indexPath</span>: <span class="hljs-type">IndexPath</span>) -&gt; <span class="hljs-type">UITableViewCell</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>在第二个方法中，通常是为了指定TableView中的内容从哪来，同时也有一个很重要的方法，即重用单元格，从可重用队列中取出一个单元格实例，可以节约内存开销。通常我们会在类中设置一个常量字符串作为标识符。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> reuseIdentify <span class="hljs-operator">=</span> <span class="hljs-string">&quot;reusedCell&quot;</span><br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">ViewController</span>:<span class="hljs-title class_ inherited__">UITableViewDelegate</span>,<span class="hljs-title class_ inherited__">UITableViewDataSource</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">tableView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">tableView</span>: <span class="hljs-type">UITableView</span>, <span class="hljs-params">numberOfRowsInSection</span> <span class="hljs-params">section</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ViewController</span>.<span class="hljs-keyword">self</span>.data.count<br>    &#125;<br>    <br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">tableView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">tableView</span>: <span class="hljs-type">UITableView</span>, <span class="hljs-params">cellForRowAt</span> <span class="hljs-params">indexPath</span>: <span class="hljs-type">IndexPath</span>) -&gt; <span class="hljs-type">UITableViewCell</span> &#123;<br>        <span class="hljs-keyword">let</span> cell <span class="hljs-operator">=</span> tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type">ViewController</span>.<span class="hljs-keyword">self</span>.reuseIdentify, for: indexPath)<br>        <br>        cell.textLabel<span class="hljs-operator">?</span>.text <span class="hljs-operator">=</span> <span class="hljs-type">ViewController</span>.<span class="hljs-keyword">self</span>.data[indexPath.row]<br>        cell.textLabel<span class="hljs-operator">?</span>.textColor <span class="hljs-operator">=</span> .black<br>        cell.selectionStyle <span class="hljs-operator">=</span> .none<br>        cell.textLabel<span class="hljs-operator">?</span>.numberOfLines <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>        cell.textLabel<span class="hljs-operator">?</span>.textAlignment <span class="hljs-operator">=</span> .left<br>        cell.textLabel<span class="hljs-operator">?</span>.font <span class="hljs-operator">=</span> <span class="hljs-type">UIFont</span>.<span class="hljs-keyword">init</span>(name: <span class="hljs-type">ViewController</span>.fonts[<span class="hljs-type">ViewController</span>.fontIndex], size: <span class="hljs-number">16</span>)<br>        <span class="hljs-keyword">return</span> cell<br>    &#125;<br>    <br>  <span class="hljs-comment">// 代理方法，用于设置样式</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">tableView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">tableView</span>: <span class="hljs-type">UITableView</span>, <span class="hljs-params">heightForRowAt</span> <span class="hljs-params">indexPath</span>: <span class="hljs-type">IndexPath</span>) -&gt; <span class="hljs-type">CGFloat</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">CGFloat</span>(<span class="hljs-number">80</span>)<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-添加动作"><a href="#3-添加动作" class="headerlink" title="3.添加动作"></a>3.添加动作</h3><p>对于按钮类（UIButton）可以添加动作，用于与用户交互，注意在互动函数的前面一定要带上@objc</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> button:<span class="hljs-type">UIButton</span> <span class="hljs-operator">=</span> &#123;<br>    <span class="hljs-keyword">let</span> button <span class="hljs-operator">=</span> <span class="hljs-type">UIButton</span>(frame:<span class="hljs-type">CGRect</span>(x: <span class="hljs-type">ScreenWidth</span><span class="hljs-operator">/</span><span class="hljs-number">2</span> <span class="hljs-operator">-</span> <span class="hljs-number">30</span>, y: <span class="hljs-number">700</span>, width: <span class="hljs-number">60</span>, height: <span class="hljs-number">60</span>))<br>    button.setTitle(<span class="hljs-string">&quot;Click&quot;</span>, for: .normal)<br>    button.setTitleColor(.black, for: .normal)<br>    button.layer.cornerRadius <span class="hljs-operator">=</span> <span class="hljs-number">20</span><br>    button.layer.shadowOffset <span class="hljs-operator">=</span> <span class="hljs-type">CGSize</span>(width: <span class="hljs-number">5</span>, height: <span class="hljs-number">5</span>)<br>    button.backgroundColor <span class="hljs-operator">=</span> .orange<br>    button.addTarget(<span class="hljs-keyword">self</span>, action: <span class="hljs-keyword">#selector</span>(clickButton(<span class="hljs-keyword">_</span>:)), for: .touchUpInside)<br>    <span class="hljs-keyword">return</span> button<br>&#125;()<br><br><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">clickButton</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">sender</span>: <span class="hljs-type">UIButton</span>) &#123;<br>    <span class="hljs-type">ViewController</span>.fontIndex <span class="hljs-operator">=</span> (<span class="hljs-type">ViewController</span>.fontIndex <span class="hljs-operator">+</span> <span class="hljs-number">1</span>) <span class="hljs-operator">%</span> <span class="hljs-type">ViewController</span>.fonts.count<br>    tableView.reloadData()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Demo3"><a href="#Demo3" class="headerlink" title="Demo3"></a>Demo3</h2><h3 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h3><p>核心原理是使用获取到的文件路径创建一个 AVPlayer 进行视频播放，实现代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> tableView:<span class="hljs-type">UITableView</span> <span class="hljs-operator">=</span> &#123;<br>    <span class="hljs-keyword">let</span> tableView <span class="hljs-operator">=</span> <span class="hljs-type">UITableView</span>(frame: <span class="hljs-type">UIScreen</span>.main.bounds)<br>    tableView.backgroundColor <span class="hljs-operator">=</span> .black<br>    tableView.dataSource <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br>    tableView.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br>    tableView.register(<span class="hljs-type">MovieCell</span>.<span class="hljs-keyword">self</span>, forCellReuseIdentifier: <span class="hljs-type">ViewController</span>.id)<br>    <span class="hljs-keyword">return</span> tableView<br>&#125;()<br><br><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">tapButton</span>() &#123;<br>    <span class="hljs-keyword">let</span> path <span class="hljs-operator">=</span> <span class="hljs-type">Bundle</span>.main.path(forResource: <span class="hljs-string">&quot;emoji zone&quot;</span>, ofType: <span class="hljs-string">&quot;.mp4&quot;</span>)<br>    player <span class="hljs-operator">=</span> <span class="hljs-type">AVPlayer</span>(url: <span class="hljs-type">URL</span>(fileURLWithPath: path<span class="hljs-operator">!</span>))<br>    playerViewController.player <span class="hljs-operator">=</span> player<br><br>    <span class="hljs-keyword">self</span>.present(playerViewController, animated: <span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">self</span>.playerViewController.player<span class="hljs-operator">?</span>.play()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Demo4"><a href="#Demo4" class="headerlink" title="Demo4"></a>Demo4</h2><h3 id="定义collection类"><a href="#定义collection类" class="headerlink" title="定义collection类"></a>定义collection类</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> collectionView: <span class="hljs-type">UICollectionView</span> <span class="hljs-operator">=</span> &#123;<br>    <span class="hljs-keyword">let</span> layout <span class="hljs-operator">=</span> <span class="hljs-type">UICollectionViewFlowLayout</span>()<br>    layout.scrollDirection <span class="hljs-operator">=</span> .horizontal<br>    <span class="hljs-keyword">let</span> collectionView <span class="hljs-operator">=</span> <span class="hljs-type">UICollectionView</span>(frame: <span class="hljs-type">CGRect</span>(x: <span class="hljs-type">ScreenWidth</span> <span class="hljs-operator">/</span> <span class="hljs-number">2</span> <span class="hljs-operator">-</span> <span class="hljs-number">195</span>, y: <span class="hljs-type">ScreenHeight</span> <span class="hljs-operator">/</span> <span class="hljs-number">2</span> <span class="hljs-operator">-</span> <span class="hljs-number">220</span>, width: <span class="hljs-number">390</span>, height: <span class="hljs-number">440</span>), collectionViewLayout: layout)<br>    collectionView.backgroundColor <span class="hljs-operator">=</span> .clear<br>    collectionView.dataSource <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br>    collectionView.delegate <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span><br>    collectionView.register(<span class="hljs-type">CustomCell</span>.classForCoder(), forCellWithReuseIdentifier: id)<br>    <span class="hljs-keyword">return</span> collectionView<br>&#125;()<br></code></pre></td></tr></table></figure><p>同样要设置数据源与代理方法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_ inherited__">UICollectionViewDataSource</span>,<span class="hljs-title class_ inherited__">UICollectionViewDelegate</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">collectionView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">collectionView</span>: <span class="hljs-type">UICollectionView</span>, <span class="hljs-params">numberOfItemsInSection</span> <span class="hljs-params">section</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> data.count<br>    &#125;<br>    <br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">collectionView</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">collectionView</span>: <span class="hljs-type">UICollectionView</span>, <span class="hljs-params">cellForItemAt</span> <span class="hljs-params">indexPath</span>: <span class="hljs-type">IndexPath</span>) -&gt; <span class="hljs-type">UICollectionViewCell</span> &#123;<br>        <span class="hljs-keyword">let</span> cell <span class="hljs-operator">=</span> collectionView.dequeueReusableCell(withReuseIdentifier: id, for: indexPath) <span class="hljs-keyword">as!</span> <span class="hljs-type">CustomCell</span><br>        cell.info <span class="hljs-operator">=</span> data[indexPath.row]<br>        <span class="hljs-keyword">return</span> cell<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Demo5"><a href="#Demo5" class="headerlink" title="Demo5"></a>Demo5</h2><h3 id="定位功能实现"><a href="#定位功能实现" class="headerlink" title="定位功能实现"></a>定位功能实现</h3><p>若要正常使用定位功能，请修改info.plist，需要添加Privacy - Location When In Use Usage Description，然后导入手机定位需要的框架</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">import</span> CoreLocation<br></code></pre></td></tr></table></figure><p>定位动作定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">requestMyLocation</span>() &#123;<br>    locationManager.requestWhenInUseAuthorization()<span class="hljs-comment">//请求定位</span><br>    locationManager.startUpdatingLocation()<span class="hljs-comment">//更新定位</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定位需要额外拓展用法</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">extension</span> <span class="hljs-title class_">ViewController</span>: <span class="hljs-title class_ inherited__">CLLocationManagerDelegate</span> &#123;<br>  <span class="hljs-comment">// 接收位置更新</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">locationManager</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">manager</span>: <span class="hljs-type">CLLocationManager</span>, <span class="hljs-params">didUpdateLocations</span> <span class="hljs-params">locations</span>: [<span class="hljs-type">CLLocation</span>]) &#123;<br>        <span class="hljs-keyword">let</span> location <span class="hljs-operator">=</span> locations[locations.count <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]<br>        locationToCity(location: location)<br>    &#125;<br>  <br>    <span class="hljs-comment">// 逆地理编码</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">locationToCity</span>(<span class="hljs-params">location</span>: <span class="hljs-type">CLLocation</span>) &#123;<br>        <span class="hljs-keyword">let</span> geocoder <span class="hljs-operator">=</span> <span class="hljs-type">CLGeocoder</span>()<br>        geocoder.reverseGeocodeLocation(location) &#123; (placeMark, error) <span class="hljs-keyword">in</span><br>            <span class="hljs-keyword">if</span> error <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">let</span> array <span class="hljs-operator">=</span> placeMark<span class="hljs-operator">!</span> <span class="hljs-keyword">as</span> <span class="hljs-type">NSArray</span><br>                <span class="hljs-keyword">let</span> mark <span class="hljs-operator">=</span> array.firstObject <span class="hljs-keyword">as!</span> <span class="hljs-type">CLPlacemark</span><br>                <span class="hljs-keyword">let</span> country <span class="hljs-operator">=</span> mark.country<span class="hljs-operator">!</span><br>                <span class="hljs-keyword">let</span> city <span class="hljs-operator">=</span> mark.locality<span class="hljs-operator">!</span><br>                <span class="hljs-keyword">self</span>.label.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Country: <span class="hljs-subst">\(String(describing: country))</span><span class="hljs-subst">\n</span> City: <span class="hljs-subst">\(String(describing: city))</span>&quot;</span><br>            &#125;<br>        &#125;<br>    &#125;<br>  <span class="hljs-comment">// 错误处理</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">locationManager</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">manager</span>: <span class="hljs-type">CLLocationManager</span>, <span class="hljs-params">didFailWithError</span> <span class="hljs-params">error</span>: <span class="hljs-type">Error</span>) &#123;<br>        <span class="hljs-keyword">self</span>.label.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;出错了！&quot;</span> <span class="hljs-operator">+</span> error.localizedDescription<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Demo6"><a href="#Demo6" class="headerlink" title="Demo6"></a>Demo6</h2><h3 id="下拉刷新"><a href="#下拉刷新" class="headerlink" title="下拉刷新"></a>下拉刷新</h3><p>实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">lazy</span> <span class="hljs-keyword">var</span> refreshControl: <span class="hljs-type">UIRefreshControl</span> <span class="hljs-operator">=</span> &#123;<br>    <span class="hljs-keyword">let</span> refreshControl <span class="hljs-operator">=</span> <span class="hljs-type">UIRefreshControl</span>()<br>    <span class="hljs-keyword">let</span> attributes <span class="hljs-operator">=</span> [<span class="hljs-type">NSAttributedString</span>.<span class="hljs-type">Key</span>.foregroundColor: <span class="hljs-type">UIColor</span>.white, <span class="hljs-type">NSAttributedString</span>.<span class="hljs-type">Key</span>.font: <span class="hljs-type">UIFont</span>.systemFont(ofSize: <span class="hljs-number">18</span>)]<br>    refreshControl.attributedTitle <span class="hljs-operator">=</span> <span class="hljs-type">NSAttributedString</span>(string: <span class="hljs-string">&quot;上次更新在：<span class="hljs-subst">\(Date())</span>&quot;</span>,attributes: attributes)<br><br>    refreshControl.addTarget(<span class="hljs-keyword">self</span>, action: <span class="hljs-keyword">#selector</span>(pullToRefresh), for: .valueChanged)<br><br>    refreshControl.tintColor <span class="hljs-operator">=</span> .white<br>    refreshControl.backgroundColor <span class="hljs-operator">=</span> .black<br>    <span class="hljs-keyword">return</span> refreshControl<br>&#125;()<br><br><span class="hljs-keyword">@objc</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">pullToRefresh</span>() &#123;<br>    <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="hljs-type">DispatchTime</span>.now()<span class="hljs-operator">+</span><span class="hljs-number">2</span> ) &#123;<br>        <span class="hljs-keyword">self</span>.data.append(<span class="hljs-keyword">self</span>.newFavoriteEmoji[<span class="hljs-keyword">self</span>.index])<br>        <span class="hljs-keyword">self</span>.index <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">self</span>.index <span class="hljs-operator">%=</span> <span class="hljs-keyword">self</span>.newFavoriteEmoji.count<br>        <span class="hljs-keyword">self</span>.tableView.reloadData()<br>        <span class="hljs-keyword">self</span>.refreshControl.endRefreshing()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Demo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
